#*********************************************************************************************
# Copyright (C) 2019 by MorphStore-Team                                                      *
#                                                                                            *
# This file is part of MorphStore - a compression aware vectorized column store.             *
#                                                                                            *
# This program is free software: you can redistribute it and/or modify it under the          *
# terms of the GNU General Public License as published by the Free Software Foundation,      *
# either version 3 of the License, or (at your option) any later version.                    *
#                                                                                            *
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;  *
# without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *
# See the GNU General Public License for more details.                                       *
#                                                                                            *
# You should have received a copy of the GNU General Public License along with this program. *
# If not, see <http://www.gnu.org/licenses/>.                                                *
#*********************************************************************************************

"""
Generation of the MorphStore C++ source code for an entire query.

This module is about the generation the of C++ source code representation of
the abstract representation of the translated program as a whole. That is, for
creating a complete CPP file compilable as a part of MorphStore without further
manual effort. The general frame for the CPP file is provided by a template CPP
file. That template file contains certain comment lines, which are replaced by
the translated program. Use function generate() to generate the C++ source code
of an abstract representation of the translated program.
"""

# TODO Document parameters and return values.
# TODO Support outputting the SQL-query again as a comment in the generated C++
#      code.
# TODO Use the result column names MonetDB uses for the output.
# TODO Output line numbers in error messages.
# TODO The format in which the C++ program outputs its result should be a
#      parameter -- either here or in the generated C++ program.
# TODO Automatically break generated C++ source code lines in a nice way.
# TODO This module is not independent from the C++ template file. For instance,
#      it relies on the existence of certain header includes and variables in
#      the template. They should be completely independent.
# TODO Use constants for common literals ("binary_io", "load", "uncompr_f", the
#      monitoring macros, etc.) as in module operators.
# TODO Output the command line arguments passed to mal2x.py in the
#      generated C++ files.


import mal2morphstore.analysis
import mal2morphstore.compr as compr
import mal2morphstore.formats as formats
from mal2morphstore.operators import Op, Morph
import mal2morphstore.processingstyles as ps
import mal2morphstore.purposes as pp

import os.path
import re
import sys

# TODO This is relative to ssb.sh.
sys.path.append(".")
import csvutils

# *****************************************************************************
# Constants
# *****************************************************************************

RES_SUFFIX = "__res"


# *****************************************************************************
# * Functions producing the insertable code snippets
# *****************************************************************************

def _printDocu(indent, tr):
    """
    Prints a little "documentation" saying that the C++ code was automatially
    generated by this script.
    """
    
    print("{}/**".format(indent))
    # The filename is unknown to this script, since the output is printed to
    # stdout.
    #print("{} * @file ...".format(indent)
    print("{} * @brief This file was automatically generated by {}.".format(
        indent, os.path.basename(sys.argv[0]))
    )
    print("{} */".format(indent))

def _printHeaders(indent, tr, purpose, processingStyle, versionSelect):
    """
    Prints preprocessor directives for the necessary header includes.
    """

    # Add the headers required for the query operators, tailored to the
    # selected processing style.
    # TODO switch include directories depending on vector version
    if (versionSelect == 1):
      for el in tr.baseMorphs + tr.prog + tr.resultMorphs:
          if isinstance(el, Op):
              for header in el.headers:
                  tr.headers.add(header.format(
                          **{
                              ps.INCLUDE_DIR_KEY:
                              ps.INCLUDE_DIR_HANDCODED[processingStyle]
                          }
                  ))
    else:             
      for el in tr.baseMorphs + tr.prog + tr.resultMorphs:
          if isinstance(el, Op):
              for header in el.headers:
                  tr.headers.add(header.format(
                          **{
                              ps.INCLUDE_DIR_KEY:
                              ps.INCLUDE_DIR_LIB[processingStyle]
                          }
                  ))
        
    # Add monitoring header if required.
    if purpose in [pp.PP_TIME, pp.PP_DATACH, pp.PP_SIZE]:
        tr.headers.add("core/utils/monitoring.h")
    
    # Add header for data analysis if required.
    if purpose == pp.PP_DATACH:
        tr.headers.add("core/utils/data_properties.h")
        
    # Add headers for all formats if required.
    if purpose == pp.PP_SIZE:
        for fmt in formats.getAllFormats(processingStyle):
            compr._addHeaders(tr, fmt)
    
    # Print headers in lexicographical order.
    for header in sorted(tr.headers):
        print("{}#include <{}>".format(indent, header))
        
    
    if (versionSelect == 2):
        print("{}using namespace vectorlib;".format(indent))
    
def _printSchema(indent, tr):
    """
    Prints the definition of a struct for each table used by the translated
    program. The struct of each table has one field for each column used from
    that table by the translated program.
    """
    
    for tblName in sorted(tr.colNamesByTblName):
        print("{}struct {}_t {{".format(indent, tblName))
        for colName in sorted(tr.colNamesByTblName[tblName]):
            print("{}    const column<uncompr_f> * {};".format(indent, colName))
        print("{}}} {};".format(indent, tblName))
        print()

def _prepareOutColsForRandomAccess(indent, op, ar):
    for key in op.__dict__:
        if key.startswith("out") and key.endswith("Col"):
            varName = getattr(op, key)
            if varName in ar.varsRndAccessUnsorted or varName in ar.varsRndAccessSorted:
                print("{}{}->template prepare_for_random_access<{}>();".format(
                        indent, varName, ps.PS_VAR
                ))

def _printDataLoad(indent, tr, ar):
    """
    Prints C++ statements for loading the data of each column used by the
    translated program from a file on disk.
    """
    
    # Load the base columns.
    print("{}// Load the base columns.".format(indent))
    maxLen = max([
        len(tblName) + 1 + len(colName)
        for tblName in tr.colNamesByTblName
        for colName in tr.colNamesByTblName[tblName]
    ])
    for tblName in sorted(tr.colNamesByTblName):
        for colName in sorted(tr.colNamesByTblName[tblName]):
            fullName = "{}.{}".format(tblName, colName)
            print(
                "{{}}{{: <{}}} = binary_io<uncompr_f>::load(dataPath + \"/{{}}.uncompr_f.bin\");".format(
                    maxLen
                ).format(
                    indent,
                    fullName,
                    fullName
                )
            )
    print()
    
    # Morph the base columns.
    if len(tr.baseMorphs):
        print("{}// Morph the base columns.".format(indent))
        for op in sorted(tr.baseMorphs, key=lambda op: op.inCol):
            print("{}{}".format(indent, op).replace("\n", "\n" + indent))
            _prepareOutColsForRandomAccess(indent, op, ar)
    else:
        print("{}// No morphing of the base columns required.".format(indent))
    print()
    
def _printFreeIntermediates(
    indent, tr, freeMorphedBaseCols, freeQueryResultCols
):
    # TODO This should also work with MorphStore's own memory manager.
    print("#ifdef MSV_NO_SELFMANAGED_MEMORY")
    freedVars = set()
    morphedBaseCols = [morphOp.outCol for morphOp in tr.baseMorphs]
    for el in tr.prog:
        if isinstance(el, Op):
            for key in el.__dict__:
                if key.endswith("Col"):
                    varName = getattr(el, key)
                    if (
                        "." not in varName
                        and varName not in freedVars
                        and (freeMorphedBaseCols or varName not in morphedBaseCols)
                        and (freeQueryResultCols or varName not in tr.resultCols)
                    ):
                        print("{}delete {};".format(indent, varName))
                        freedVars.add(varName)
    print("#endif")

def _printFreeQueryResults(indent, tr, suffix=""):
    print("#ifdef MSV_NO_SELFMANAGED_MEMORY")
    for colName in tr.resultCols:
        print("{}delete {}{};".format(indent, colName, suffix))
    print("#endif")
    
def _printProg(indent, tr, purpose, ar, ps, colInfosFilePath, repetitionCount):
    """
    Prints the core program, i.e., the sequence of operators.
    """
    
    # The query program.
    if purpose == pp.PP_TIME:
        # Constants for the monitoring column names.
        varColOpName = "colOpName"
        varColOpIdx = "colOpIdx"
        varColRuntime = "colRuntime"
        print("{}// Constants for the monitoring column names.".format(indent))
        for varName, varVal in [
            # (C++ constant name, CSV column name)
            (varColOpName , "opName"),
            (varColOpIdx  , "opIdx"),
            (varColRuntime, "runtime"),
        ]:
            print('{}const std::string {} = "{}";'.format(
                    indent, varName, varVal
            ))
        print()
        
        # Helpers.
        def isOp(el):
            return isinstance(el, Op)
        
        # Constants for the monitoring keys.
        varOpNameFs = "opName_{}"
        opNameQuery = "query"
        varOpNameQuery = varOpNameFs.format(opNameQuery)
        maxVarOpNameLen = len(varOpNameFs) - len("{}") + max(
                map(
                        lambda op: len(op.opName),
                        filter(isOp, tr.prog)
                )
        )
        print("{}// Constants for the distinct operator names.".format(indent))
        for opIdx, opName in enumerate(
                [opNameQuery] + \
                list(sorted(set([op.opName for op in filter(isOp, tr.prog)])))
        ):
            print(
                    '{{}}const std::string {{: <{}}} = "{{}}";'
                    .format(maxVarOpNameLen)
                    .format(indent, varOpNameFs.format(opName), opName)
            )
        print()
        
        # Creation of the monitors.
        print("{}// Creation of the monitors.".format(indent))
        for opIdx, opName in enumerate(
                [opNameQuery] + \
                [op.opName for op in filter(isOp, tr.prog)]
        ):
            print(
                    '{{}}MONITORING_CREATE_MONITOR(MONITORING_MAKE_MONITOR({{: <{}}}, {{: >{}}}), MONITORING_KEY_IDENTS({{}}, {{}}));'
                    .format(maxVarOpNameLen, 2)
                    .format(
                            indent,
                            varOpNameFs.format(opName),
                            opIdx,
                            varColOpName,
                            varColOpIdx
                    )
            )
        print()
        
        # Variables for the query result columns.
        print("{}// Variables for the query result columns.".format(indent))
        for colName in tr.resultCols:
            # TODO Don't hardcode the format.
            print("{}const column<uncompr_f> * {}{};".format(
                    indent, colName, RES_SUFFIX
            ))
        print()
        
        # Query program.
        print("{}std::cerr << std::endl;".format(indent))
        print()
        print("{}for(unsigned repIdx = 1; repIdx <= {}; repIdx++) {{".format(
                indent, repetitionCount
        ))
        indentMore = "{}    ".format(indent)
        print('{}std::cerr << "\\tRepetition " << repIdx << " started... ";'.format(
                indentMore
        ))
        print()
        print("{}// Query program.".format(indentMore))
        print(
                '{}MONITORING_START_INTERVAL_FOR({}, {}, {});'
                .format(indentMore, varColRuntime, varOpNameQuery, 0)
        )
        print()
        opIdx = 1
        for el in tr.prog:
            if isinstance(el, Op):
                monVarOpNameOp = varOpNameFs.format(el.opName)
                print('{}MONITORING_START_INTERVAL_FOR({}, {}, {});'.format(
                        indentMore, varColRuntime, monVarOpNameOp, opIdx)
                )
                print("{}{}".format(indentMore, el).replace("\n", "\n" + indentMore))
                print('{}MONITORING_END_INTERVAL_FOR  ({}, {}, {});'.format(
                        indentMore, varColRuntime, monVarOpNameOp, opIdx)
                )
                _prepareOutColsForRandomAccess(indentMore, el, ar)
                opIdx += 1
            else:
                print("{}{}".format(indentMore, el).replace("\n", "\n" + indentMore))
        print()
        print(
                '{}MONITORING_END_INTERVAL_FOR  ({}, {}, {});'
                .format(indentMore, varColRuntime, varOpNameQuery, 0)
        )
        print()
        
        # Free all intermediate results which are not morphed base columns or
        # query results.
        # TODO This should happen as early as possible during query processing.
        print(
                "{}// Free all intermediate results which are not morphed "
                "base columns or query results.".format(indentMore)
        )
        _printFreeIntermediates(indentMore, tr, False, False)
        print()
        print("{}// Handle query results.".format(indentMore))
        print("{}if(repIdx < {}) {{".format(indentMore, repetitionCount))
        print("{}    // This is not the last query repetition.".format(indentMore))
        _printFreeQueryResults(indentMore + "    ", tr, "")
        print("{}}}".format(indentMore))
        print("{}else {{".format(indentMore))
        print("{}    // This is the last query repetition.".format(indentMore))
        for colName in tr.resultCols:
            print("{}    {}{} = {};".format(indentMore, colName, RES_SUFFIX, colName))
        print("{}}}".format(indentMore))
        
        print()
        print('{}std::cerr << "done." << std::endl;'.format(indentMore))
        
        print("{}}}".format(indent))
        
        print()
        print('{}std::cerr << "Query execution ";'.format(indent))
    elif purpose == pp.PP_DATACH:
        # Constants for the monitoring column names.
        varColOpName = "colOpName"
        varColOpIdx = "colOpIdx"
        varColColRole = "colColRole"
        varColColName = "colColName"
        varColValueCount = "colValueCount"
        varColIsResult = "colIsResult"
        varColUsedBytes = "colUsedBytes"
        varColHasRndAccUnsorted = "colHasRndAccessUnsorted"
        varColHasRndAccSorted = "colHasRndAccessSorted"
        varColIsForcedUncompr = "colIsForcedUncompr"
        print("{}// Constants for the monitoring column names.".format(indent))
        for varName, varVal in [
            # (C++ constant name, CSV column name)
            (varColOpName, "opName"),
            (varColOpIdx, "opIdx"),
            (varColColRole, "colRole"),
            (varColColName, "colName"),
            (varColValueCount, "valueCount"),
            (varColIsResult, "isResult"),
            (varColUsedBytes, "UsedBytes"),
            (varColHasRndAccUnsorted, "hasRndAccessUnsorted"),
            (varColHasRndAccSorted, "hasRndAccessSorted"),
            (varColIsForcedUncompr, "isForcedUncompr"),
        ]:
            print('{}const std::string {} = "{}";'.format(
                    indent, varName, varVal
            ))
        print()

        # Helpers.
        def isOp(el):
            return isinstance(el, Op)

        # Constants for the monitoring keys.
        varOpNameFs = "opName_{}"
        maxVarOpNameLen = len(varOpNameFs) - len("{}") + max(
                map(
                        lambda op: len(op.opName),
                        filter(isOp, tr.prog)
                )
        )
        print("{}// Constants for the distinct operator names.".format(indent))
        for opIdx, opName in enumerate(
                list(sorted(set([op.opName for op in filter(isOp, tr.prog)]))),
                start=1
        ):
            print(
                    '{{}}const std::string {{: <{}}} = "{{}}";'
                    .format(maxVarOpNameLen)
                    .format(indent, varOpNameFs.format(opName), opName)
            )
        print()

        # Creation of the monitors.
        print("{}// Creation of the monitors.".format(indent))
        for opIdx, op in enumerate(
                [op for op in filter(isOp, tr.prog)],
                start=1
        ):
            for foo in sorted(op.__dict__):
                if (foo.startswith("in") or foo.startswith("out")) and foo.endswith("Col"):
                    print(
                            '{{}}MONITORING_CREATE_MONITOR(MONITORING_MAKE_MONITOR({{: <{}}}, {{: >{}}}, "{{: <{}}}", "{{: <{}}}"), MONITORING_KEY_IDENTS({{}}, {{}}, {{}}, {{}}));'
                            .format(maxVarOpNameLen, 2, 0, 0)
                            .format(
                                    indent,
                                    varOpNameFs.format(op.opName),
                                    opIdx,
                                    foo,
                                    op.__dict__[foo],
                                    varColOpName,
                                    varColOpIdx,
                                    varColColRole,
                                    varColColName,
                            )
                    )
        print()

        # Query program.
        print("{}// Query program.".format(indent))
        print()
        opIdx = 1
        for el in tr.prog:
            if isinstance(el, Op):
                monVarOpNameOp = varOpNameFs.format(el.opName)
                print("{}{}".format(indent, el).replace("\n", "\n" + indent))
                _prepareOutColsForRandomAccess(indent, el, ar)
                for foo in sorted(el.__dict__):
                    if (foo.startswith("in") or foo.startswith("out")) and foo.endswith("Col"):
                        print("{}{{".format(indent))
                        print('{}MONITORING_ADD_DATAPROPERTIES_FOR("", data_properties({}, {}), {}, {}, "{}", "{}");'.format(
                                2*indent,
                                el.__dict__[foo],
                                "true" if el.__dict__[foo] in ar.varsUnique else "false",
                                monVarOpNameOp, opIdx, foo, el.__dict__[foo]
                        ))
                        print('{}MONITORING_ADD_INT_FOR({}, {}->get_count_values(), {}, {}, "{}", "{}");'.format(
                                2*indent, varColValueCount, el.__dict__[foo], monVarOpNameOp, opIdx, foo, el.__dict__[foo])
                        )
                        print('{}MONITORING_ADD_BOOL_FOR({}, {}, {}, {}, "{}", "{}");'.format(
                                2*indent, varColIsResult,
                                "true" if (el.__dict__[foo] in tr.resultCols) else "false",
                                monVarOpNameOp, opIdx, foo, el.__dict__[foo])
                        )
                        print('{}MONITORING_ADD_INT_FOR({}, {}->get_size_used_byte(), {}, {}, "{}", "{}");'.format(
                                2*indent, varColUsedBytes, el.__dict__[foo], monVarOpNameOp, opIdx, foo, el.__dict__[foo])
                        )
                        print('{}MONITORING_ADD_BOOL_FOR({}, {}, {}, {}, "{}", "{}");'.format(
                                2*indent, varColHasRndAccUnsorted,
                                "true" if (el.__dict__[foo] in ar.varsRndAccessUnsorted) else "false",
                                monVarOpNameOp, opIdx, foo, el.__dict__[foo])
                        )
                        print('{}MONITORING_ADD_BOOL_FOR({}, {}, {}, {}, "{}", "{}");'.format(
                                2*indent, varColHasRndAccSorted,
                                "true" if (el.__dict__[foo] in ar.varsRndAccessSorted) else "false",
                                monVarOpNameOp, opIdx, foo, el.__dict__[foo])
                        )
                        print('{}MONITORING_ADD_BOOL_FOR({}, {}, {}, {}, "{}", "{}");'.format(
                                2*indent, varColIsForcedUncompr,
                                "true" if (el.__dict__[foo] in ar.varsForcedUncompr) else "false",
                                monVarOpNameOp, opIdx, foo, el.__dict__[foo])
                        )
                        print("{}}}".format(indent))
                
                for foo in sorted(el.__dict__):
                    if (foo.endswith("F")):
                        if ("uncompr" in el.__dict__[foo]):
                            print('{}MONITORING_ADD_INT_FOR("format", {}, {}, {}, "{}", "{}");'.format(indent,  0,  monVarOpNameOp, opIdx, foo[:-1] + "Col", el.__dict__[foo[:-1] + "Col"]))
                        elif ("static_vbp" in el.__dict__[foo]):
                            print('{}MONITORING_ADD_INT_FOR("format", {}, {}, {}, "{}", "{}");'.format(indent, 1,  monVarOpNameOp, opIdx, foo[:-1] + "Col", el.__dict__[foo[:-1] + "Col"]))
                        elif ("dynamic_vbp" in el.__dict__[foo]):
                            print('{}MONITORING_ADD_INT_FOR("format", {}, {}, {}, "{}", "{}");'.format(indent, 2,  monVarOpNameOp, opIdx, foo[:-1] + "Col", el.__dict__[foo[:-1] + "Col"]))
                        elif ("rle" in el.__dict__[foo]):
                            print('{}MONITORING_ADD_INT_FOR("format", {}, {}, {}, "{}", "{}");'.format(indent, 3,  monVarOpNameOp, opIdx, foo[:-1] + "Col", el.__dict__[foo[:-1] + "Col"]))
                        else:
                            print('{}MONITORING_ADD_INT_FOR("format", {}, {}, {}, "{}", "{}");'.format(indent, 4,  monVarOpNameOp, opIdx, foo[:-1] + "Col", el.__dict__[foo[:-1] + "Col"]))   
                
                opIdx += 1
            else:
                print("{}{}".format(indent, el).replace("\n", "\n" + indent))
        print()
    elif purpose == pp.PP_SIZE:
        # Constants for the monitoring column names.
        varColColName = "colColName"
        varColFormatWithBw = "colFormatWithBw"
        varColFormatWithoutBw = "colFormatWithoutBw"
        varColValueCount = "colValueCount"
        varColValueCountCompr = "colValueCountCompr"
        varColUsedBytes = "colUsedBytes"
        varColComprBytes = "colComprBytes"
        print("{}// Constants for the monitoring column names.".format(indent))
        for varName, varVal in [
            # (C++ constant name, CSV column name)
            (varColColName, "colName"),
            (varColFormatWithBw, "formatWithBw"),
            (varColFormatWithoutBw, "formatWithoutBw"),
            (varColValueCount, "valueCount"),
            (varColValueCountCompr, "valueCountCompr"),
            (varColUsedBytes, "sizeUsedByte"),
            (varColComprBytes, "sizeComprByte"),
        ]:
            print('{}const std::string {} = "{}";'.format(
                    indent, varName, varVal
            ))
        print()
        
        # Regarding (un)compressed formats.
        allFormats = formats.getAllFormats(ps)
        uncompr = formats.UncomprFormat()
        sMaxBw = csvutils.getColInfos(colInfosFilePath)[csvutils.ColInfoCols.maxBw]
        def _setBitwidthIf(fmt, varName):
            return fmt.changeBw(sMaxBw[varName]) \
                    if isinstance(fmt, formats.StaticVBPFormat) \
                    else fmt

        # Creation of the monitors.
        print("{}// Creation of the monitors.".format(indent))
        varNames = set()
        for el in tr.prog:
            if isinstance(el, Op):
                for key in el.__dict__:
                    if key.endswith("Col"):
                        varNames.add(getattr(el, key))
        for varName in varNames:
            for fmt in allFormats:
                print(
                    '{}MONITORING_CREATE_MONITOR(MONITORING_MAKE_MONITOR("{}", "{}", "{}"), MONITORING_KEY_IDENTS({}, {}, {}));'
                    .format(
                            indent,
                            varName,
                            _setBitwidthIf(fmt, varName).getInternalName(),
                            fmt.getInternalName(),
                            varColColName,
                            varColFormatWithBw,
                            varColFormatWithoutBw,
                    )
                )
        print()
        
        def _morphToAllFormats(varName):
#            print(
#                '{}std::cerr << "\\tmorphing column {} to all formats..." << '
#                'std::endl;'.format(indent, varName)
#            )
            for fmt in allFormats:
                msFormatNameWithBw = _setBitwidthIf(fmt, varName).getInternalName()
                msFormatNameWithoutBw = fmt.getInternalName()
                newVarName = "{}__m".format(varName.replace(".", "_"))
                print("{}{{".format(indent))
#                print('{}std::cerr << "\\t\\t{}... ";'.format(
#                    2 * indent, msFormatNameWithoutBw
#                ))
                print("{}{}".format(
                    2 * indent, Morph(newVarName, varName, msFormatNameWithBw)
                ))
#                print('{}std::cerr << "done." << std::endl;'.format(
#                    2 * indent, msFormatNameWithoutBw
#                ))
                for method, colName in [
                    ("get_count_values"      , varColValueCount),
                    ("get_count_values_compr", varColValueCountCompr),
                    ("get_size_used_byte"    , varColUsedBytes),
                    ("get_size_compr_byte"   , varColComprBytes),
                ]:
                    print('{}MONITORING_ADD_INT_FOR({}, {}->{}(), "{}", "{}", "{}");'.format(
                            2 * indent,
                            colName,
                            newVarName,
                            method,
                            varName,
                            msFormatNameWithBw,
                            msFormatNameWithoutBw
                    ))
                if fmt != uncompr:
                    print("{}delete {};".format(2 * indent, newVarName))
                print("{}}}".format(indent))
#            print('{}std::cerr << "\\tdone." << std::endl;'.format(indent))

        
        # Morphing the base data to all formats.
        print("{}// Morphing the base data to all formats.".format(indent))
        for tblName in tr.colNamesByTblName:
            for colName in tr.colNamesByTblName[tblName]:
                _morphToAllFormats("{}.{}".format(tblName, colName))
        print()
        
        # Query program.
        print("{}// Query program.".format(indent))
        print()
        for el in tr.prog:
            if isinstance(el, Op):
                print("{}{}".format(indent, el).replace("\n", "\n" + indent))
                _prepareOutColsForRandomAccess(indent, el, ar)
                
                for key in el.__dict__:
                    if key.startswith("out") and key.endswith("Col"):
                        varName = getattr(el, key)
                        _morphToAllFormats(varName)
            else:
                print("{}{}".format(indent, el).replace("\n", "\n" + indent))
        print()
    elif purpose in [pp.PP_CHECK, pp.PP_RESULTS]:
        for el in tr.prog:
            print("{}{}".format(indent, el).replace("\n", "\n" + indent))
            if isinstance(el, Op):
                _prepareOutColsForRandomAccess(indent, el, ar)
    else:
        raise RuntimeError("unsupported purpose: '{}'".format(purpose))

def _printResultOutput(indent, tr, purpose):
    """
    Prints C++ statements for the output of the query's result columns.
    """

    # Print the monitoring data.
    if purpose in [pp.PP_TIME, pp.PP_DATACH, pp.PP_SIZE]:
        print("{}// Print the monitoring data.".format(indent))
        print('{}std::cout << "[MEA]" << std::endl;'.format(indent))
        print("{}MONITORING_PRINT_MONITORS(monitorCsvLog);".format(indent))
        print('{}std::cout << "[RES]" << std::endl;'.format(indent))
        print()
    
    # Morph the result columns.
    if len(tr.resultMorphs):
        print("{}// Morph the result columns.".format(indent))
        for op in sorted(tr.resultMorphs, key=lambda op: op.inCol):
            print("{}{}".format(indent, op).replace("\n", "\n" + indent))
    else:
        print("{}// No morphing of the result columns required.".format(indent))
    print()
    
    # TODO For the time purpose, the handling of the result columns is
    # probably not correct, if they are not directly created in the
    # uncompressed format. However, at the moment this is not a problem.
    
    # Print the result columns.
    if purpose == pp.PP_TIME:
        outputCols = map(
                lambda colName: "{}{}".format(colName, RES_SUFFIX),
                tr.resultCols
        )
    else:
        outputCols = tr.resultCols
    print("{}// Print the result columns.".format(indent))
    if True:
        # Output in the same CSV dialect MonetDB uses.
        print("{}print_columns_csv({{{}}});".format(
            indent,
            ", ".join(outputCols)
        ))
    else:
        print("{}print_columns(print_buffer_base::decimal, {});".format(
            indent,
            ", ".join(outputCols)
        ))
    print()
    
    # Free all intermediate and/or query results.
    if purpose == pp.PP_TIME:
        print("{}// Free all query results.".format(indent))
        _printFreeQueryResults(indent, tr, RES_SUFFIX)
    else:
        # TODO This should happen as early as possible during query processing.
        print("{}// Free all intermediate results.".format(indent))
        _printFreeIntermediates(indent, tr, True, True)

def _printAnalysis(indent, ar):
    """
    Prints C++ comments containing some interesting facts about the translated
    program.
    """

    print("{}//         Intermediates used before assigned".format(indent))
    if len(ar.varsUsedBeforeAssigned):
        print("{}// [WARN]: Found the following:".format(indent))
        for var in ar.varsUsedBeforeAssigned:
            print("{}//         - {}".format(indent, var))
    else:
        print("{}// [good]: Found none.".format(indent))
        
    print("{}//".format(indent))
        
    print("{}//         Intermediates never used".format(indent))
    if len(ar.varsNeverUsed):
        print("{}// [WARN]: Found the following:".format(indent))
        for var in ar.varsNeverUsed:
            print("{}//         - {}".format(indent, var))
    else:
        print("{}// [good]: Found none.".format(indent))
        
        
# *****************************************************************************
# * Function for generating the C++ source code as a whole
# *****************************************************************************

# Regular expression for recognizing comment lines in the template CPP file to
# replace by parts of the translated program.
_pPlaceholder = re.compile(r"(\s*)\/\/ ##### mal2morphstore (.+?) #####\s*")

def generate(
        translationResult,
        templateFilePath,
        purpose,
        processingStyle,
        versionSelect,
        statDirPath,
        colInfosFilePath,
        repetitionCount,
):
    """
    Generates the C++ source code for the given abstract representation of a
    translated program and prints it to stdout.
    
    This code generation is based on a template CPP file providing the general
    frame of the C++ program, i.e., the parts which are independent of the
    particular query. This template file is copied to the output line by line,
    whereby special comment lines are replaced by query-dependent C++ source
    snippets. These special comment lines have the following structure:
    "// ##### mal2morphstore ph #####". They can appear at any indentation
    level and the indentation of the comment is used for all lines which are
    inserted. ph is a placeholder for the kind of source snippet to be
    inserted. The supported placeholders are:
    - docu     : A small comment saying that the code was generated
    - headers  : C++ header includes required by the translated program
    - schema   : Definition of structs for the required tables
    - dataload : Loading the base data from files
    - prog     : The core of the query program, i.e., the sequence of operators
    - result   : The output of the query's result
    - analysis : Some interesting facts about the translated program
    """
    
    with open(templateFilePath, "r") as templateFile:
        ar = mal2morphstore.analysis.analyze(
                translationResult, True, statDirPath
        )
        for line in templateFile:
            line = line.rstrip()
            mPlaceholder = _pPlaceholder.fullmatch(line)
            if mPlaceholder is None:
                # Copy line from template file to output.
                print(line)
            else:
                # Insert C++ code snippet.
                indent = mPlaceholder.group(1)
                ph = mPlaceholder.group(2)
                if ph == "docu":
                    _printDocu(indent, translationResult)
                elif ph == "headers":
                    _printHeaders(
                            indent,
                            translationResult,
                            purpose,
                            processingStyle,
                            versionSelect
                    )
                elif ph == "schema":
                    _printSchema(indent, translationResult)
                elif ph == "processingstyle":
                    # The constant representing the processing style to use for
                    # all operators.
                    print("{}using {} = {};".format(
                            indent, ps.PS_VAR, processingStyle
                    ))
                    print()
                elif ph == "dataload":
                    _printDataLoad(indent, translationResult, ar)
                elif ph == "prog":
                    _printProg(
                            indent,
                            translationResult,
                            purpose,
                            ar,
                            processingStyle,
                            colInfosFilePath,
                            repetitionCount,
                    )
                elif ph == "result":
                    _printResultOutput(
                            indent, translationResult, purpose
                    )
                elif ph == "analysis":
                    _printAnalysis(indent, ar)
                else:
                    raise RuntimeError(
                        "unknown placeholder in C++ template file: {}".format(
                            ph
                        )
                    )
